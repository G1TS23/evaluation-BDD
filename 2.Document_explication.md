## Membres du groupe

Nom/prénom : Olivier Falahi
Nom/prénom : Tanguy Pisano

---

### 1. Présentation du Projet

Décrivez votre application en 3-5 phrases : problématique, objectif et fonctionnalités principales.

Site de publications d'articles, avec possibilité de commenter les articles. Il faut être utilisateur pour commenter et
écrire.
Les utilisateurs et articles sont stockés sur une DB PostgreSQL et les 5 derniers articles publiés ainsi que les
commentaires sont stockés sur une DB MongoDB.

Par manque de temps, la gestion du stockage des 5 derniers articles publiés dans mongodb n'a pas été effectuée.
Egalement l'ORM comportait une sécurité au niveau NoSQL demandant une présence de replicas pour effectuer les actions de
CREATE et UPDATE, par manque de temps une option annexe n'a pas pu etre implémentée.

Nous avons commencé un front disponible à l'adresse [http://localhost:8080](http://localhost:8080) mais il n'est pas
fonctionnel
par manque de temps et suite à des problèmes rencontrés (compatibilité de navigateurs notamment et environnement
Docker).

Des exemples de requetes curl sont situées dans le README.md

### 2. Architecture PostgreSQL (Méthode Merise)

**MCD (Modèle Conceptuel de Données)**

```
USER (1,N) - écrit - (1,1) ARTICLE

```

**MLD (Modèle Logique de Données)**

```
USER (id_user, firstname, lastname, email, password, nb_article, created_at)
ARTICLE (id_article, title, description, content, id_user, created_at)
```

**MPD (Modèle Physique de Données)**

```sql
CREATE TABLE users
(
    id_user    INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    firstname  TEXT         NOT NULL,
    lastname   TEXT         NOT NULL,
    email      email UNIQUE NOT NULL,
    password   TEXT         NOT NULL,
    nb_article INTEGER      NOT NULL DEFAULT 0,
    created_at TIMESTAMP    NOT NULL DEFAULT NOW()
);

CREATE TABLE articles
(
    id_user     INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    title       TEXT      NOT NULL,
    description TEXT,
    content     TEXT      NOT NULL,
    created_at  TIMESTAMP NOT NULL DEFAULT NOW(),
    id_user     INTEGER   NOT NULL,
    CONSTRAINT fk_id_user FOREIGN KEY (id_user) REFERENCES users (id_user)
)
```

### 3. Architecture MongoDB

```mongo
db.createCollection("articles", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["title", "content", "created_at", "id_user", "article_id"],
            properties: {
                title: {
                    bsonType: "string",
                    description: "Titre obligatoire de type string"
                },
                description: {
                    bsonType: "string",
                    description: "Description obligatoire"
                },
                content: {
                    bsonType: "string",
                    description: "Contenu obligatoire"
                },
                created_at: {
                    bsonType: "date",
                    description: "Date obligatoire"
                },
                id_user: {
                    bsonType: ["int", "long", "double"],
                    description: "ID obligatoire"
                },
                article_id: {
                    bsonType: ["int", "long", "double"],
                    description: "ID obligatoire"
                },
                comments: {
                    bsonType: "array",
                    items: {
                        bsonType: "object",
                        required: ["article_id", "content", "created_at", "id_user"],
                        properties: {
                            article_id: {
                                bsonType: ["int", "long", "double"],
                                description: "Id de l'article obligatoire"
                            },
                            content: {
                                bsonType: "string",
                                description: "Contenu obligatoire"
                            },
                            created_at: {
                                bsonType: "date",
                                description: "Date obligatoire"
                            },
                            id_user: {
                                bsonType: ["int", "long", "double"],
                                description: "ID obligatoire"
                            }
                        }
                    }
                },
            }
        }
    }
});

db.createCollection("comments", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["article_id", "content", "created_at", "id_user"],
            properties: {
                article_id: {
                    bsonType: ["int", "long", "double"],
                    description: "Id de l'article obligatoire"
                },
                content: {
                    bsonType: "string",
                    description: "Contenu obligatoire"
                },
                created_at: {
                    bsonType: "date",
                    description: "Date obligatoire"
                },
                id_user: {
                    bsonType: ["int", "long", "double"],
                    description: "ID obligatoire"
                }
            }
        }
    }
});
```

### 4. Justification des Choix Techniques

- **Répartition des données** : Quelles données en PostgreSQL ? Quelles données en MongoDB ? Pourquoi ?
  Les utilisateurs et les articles sont stockés sur postgre pour garantir une meilleure persistence des données, ces
  deux tables étant essentielles au trafic du site.
  Les 5 derniers articles et les commentaires sont stockés sur MongoDB pour avoir un accès rapide à ceux ci.
- **Modélisation MongoDB** : Documents imbriqués ou références ? Justification
  Les commentaires sont mixés entre imbriqués et référencés pour avoir les derniers commentaires rapidement mais éviter
  une surcharge du fichier a cause d'un trop grand nombre de commentaires.
- **Relations inter-bases** : Comment les deux bases communiquent-elles ?
  Les tables communiquent entre elles au moyen de clés étrangères lors de création des éléments. Permettant d'effectuer
  des requetes multiples dans les cas necessaires.

### 5. Exemples de Requêtes Complexes

**PostgreSQL**

```sql
-- Exemple de requête avec jointure et agrégat
-- Moyenne d'article par mois
WITH user_avg AS (SELECT u.id_user,
                         COUNT(a.id_article)                                                 AS total_articles,
                         (EXTRACT(YEAR FROM AGE(MAX(a.created_at), MIN(a.created_at))) * 12 +
                          EXTRACT(MONTH FROM AGE(MAX(a.created_at), MIN(a.created_at))) + 1) AS total_months
                  FROM users u
                           JOIN articles a ON a.id_user = u.id_user
                  GROUP BY u.id_user)
SELECT ROUND(AVG(total_articles / total_months), 2) AS global_avg_articles_per_month
FROM user_avg;
-- Nombre articles par mois par utilisateur
SELECT u.firstname,
       u.lastname,
       COUNT(a.id_article) AS total_articles,
       ROUND(
               COUNT(a.id_article) /
               (EXTRACT(YEAR FROM AGE(MAX(a.created_at), MIN(a.created_at))) * 12 +
                EXTRACT(MONTH FROM AGE(MAX(a.created_at), MIN(a.created_at))) + 1),
               2
       )                   AS avg_articles_per_month
FROM users u
         JOIN articles a ON a.id_user = u.id_user
GROUP BY u.id_user, u.firstname, u.lastname
ORDER BY avg_articles_per_month DESC;
-- Tous les articles d'un user
SELECT u.firstname,
       u.lastname,
       a.title
FROM users u
         INNER JOIN articles a ON a.id_user = u.id_user
WHERE u.id_user = 1;
```

**MongoDB**

```mongo
// Exemple de pipeline d'agrégation
// Recuperer tous les commentaires d'un article
db.comments.aggregate([
    { $match: { article_id: 10 } },
    { $sort: { created_at: -1 } },
    { $project: {
            content: 1,
            created_at: 1,
            id_user: 1,
            article_id: 1
        }
    }
])

//Moyenne du nombre de commentaires par articles

db.comments.aggregate([
  {
    $group: {
      _id: { article_id: "$article_id" },
      total_comments: { $sum: 1 }
    }
  },
  {
    $group: {
      _id: "$_id.id_user",
      avg_comments_per_article: { $avg: "$total_comments" }
    }
  },
  {
    $project: {
      _id: 0,
      avg_comments_per_article: 1
    }
  }
]);

```

### 6. Stratégie de Sauvegarde

Pour cette partie, vous devez effectuer des recherches afin d'argumenter vos réponses.

- **PostgreSQL** : Méthode proposée (pg_dump, sauvegarde continue, etc.)

Script s'executant toutes les semaines faisant un dump de la db au moyen de pg_dump

- **MongoDB** : Méthode proposée (mongodump, replica set, etc.)

Replicas docker, soft delete et mongodump mensuel des commentaires

- **Fréquence** : Complète, incrémentale, différentielle

Mensuel pour les commentaires et hebdomadaires pour Postgres

- **Restauration** : Procédure en cas de perte de données

Recuperation au moyen des dump effectués