
## Membres du groupe
Nom/prénom : Olivier Falahi
Nom/prénom : Tanguy Pisano

---

### 1. Présentation du Projet

Décrivez votre application en 3-5 phrases : problématique, objectif et fonctionnalités principales.

Site de publications d'articles, avec possibilité de commenter les articles. Il faut être utilisateur pour commenter et écrire.
Les utilisateurs et articles sont stockés sur une DB PostgreSQL et les 5 derniers articles publiés ainsi que les commentaires sont stockés sur une DB MongoDB.

### 2. Architecture PostgreSQL (Méthode Merise)

**MCD (Modèle Conceptuel de Données)**

```
USER (1,N) - écrit - (1,1) ARTICLE

```

**MLD (Modèle Logique de Données)**

```
USER (id_user, firstname, lastname, email, password, nb_article, created_at)
ARTICLE (id_article, title, description, content, id_user, created_at)
```

**MPD (Modèle Physique de Données)**

```sql
CREATE TABLE users (
    id_user INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    firstname TEXT NOT NULL,
    lastname TEXT NOT NULL,
    email email UNIQUE NOT NULL,
    password TEXT NOT NULL,
    nb_article INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE articles (
    id_user INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    content TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    id_user INTEGER NOT NULL,
    CONSTRAINT fk_id_user FOREIGN KEY (id_user) REFERENCES users (id_user)
)
```

### 3. Architecture MongoDB

```mongo
db.createCollection("articles", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["title", "content", "created_at", "id_user", "article_id"],
            properties: {
                title: {
                    bsonType: "string",
                    description: "Titre obligatoire de type string"
                },
                description: {
                    bsonType: "string",
                    description: "Description obligatoire"
                },
                content: {
                    bsonType: "string",
                    description: "Contenu obligatoire"
                },
                created_at: {
                    bsonType: "date",
                    description: "Date obligatoire"
                },
                id_user: {
                    bsonType: "int",
                    description: "ID obligatoire"
                },
                article_id: {
                    bsonType: "int",
                    description: "ID obligatoire"
                },
                comments: {
                    bsonType: "array",
                    items: {
                        bsonType: "object",
                        required: ["article_id", "content", "created_at", "id_user"],
                        properties: {
                            article_id: {
                                bsonType: "int",
                                description: "Id de l'article obligatoire"
                            },
                            content: {
                                bsonType: "string",
                                description: "Contenu obligatoire"
                            },
                            created_at: {
                                bsonType: "date",
                                description: "Date obligatoire"
                            },
                            id_user: {
                                bsonType: "int",
                                description: "ID obligatoire"
                            }
                        }
                    }
                },
            }
        }
    }
});

db.createCollection("comments", {
    validator: {
        $jsonSchema: {
            bsonType: "object",
            required: ["article_id", "content", "created_at", "id_user"],
            properties: {
                article_id: {
                    bsonType: "int",
                    description: "Id de l'article obligatoire"
                },
                content: {
                    bsonType: "string",
                    description: "Contenu obligatoire"
                },
                created_at: {
                    bsonType: "date",
                    description: "Date obligatoire"
                },
                id_user: {
                    bsonType: "int",
                    description: "ID obligatoire"
                }
            }
        }
    }
});
```

### 4. Justification des Choix Techniques

- **Répartition des données** : Quelles données en PostgreSQL ? Quelles données en MongoDB ? Pourquoi ?
Les utilisateurs et les articles sont stockés sur postgre pour garantir une meilleure persistence des données, ces deux tables étant essentielles au trafic du site.
Les 5 derniers articles et les commentaires sont stockés sur MongoDB pour avoir un accès rapide à ceux ci. 
- **Modélisation MongoDB** : Documents imbriqués ou références ? Justification
Les commentaires sont mixés entre imbriqués et référencés pour avoir les derniers commentaires rapidement mais éviter une surcharge du fichier a cause d'un trop grand nombre de commentaires. 
- **Relations inter-bases** : Comment les deux bases communiquent-elles ?
Les tables communiquent entre elles au moyen de clés étrangères lors de création des éléments. Permettant d'effectuer des requetes multiples dans les cas necessaires.

### 5. Exemples de Requêtes Complexes

**PostgreSQL**

```sql
-- Exemple de requête avec jointure et agrégat
-- Moyenne d'article par mois
WITH user_avg AS (
    SELECT 
        u.id_user,
        COUNT(a.id_article) AS total_articles,
        (EXTRACT(YEAR FROM AGE(MAX(a.created_at), MIN(a.created_at))) * 12 +
         EXTRACT(MONTH FROM AGE(MAX(a.created_at), MIN(a.created_at))) + 1) AS total_months
    FROM users u
    JOIN articles a ON a.id_user = u.id_user
    GROUP BY u.id_user
)
SELECT 
    ROUND(AVG(total_articles / total_months), 2) AS global_avg_articles_per_month
FROM user_avg;
-- Nombre articles par mois par utilisateur
SELECT 
    u.firstname,
    u.lastname,
    COUNT(a.id_article) AS total_articles,
    ROUND(
        COUNT(a.id_article) /
        (EXTRACT(YEAR FROM AGE(MAX(a.created_at), MIN(a.created_at))) * 12 +
         EXTRACT(MONTH FROM AGE(MAX(a.created_at), MIN(a.created_at))) + 1),
        2
    ) AS avg_articles_per_month
FROM users u
JOIN articles a ON a.id_user = u.id_user
GROUP BY u.id_user, u.firstname, u.lastname
ORDER BY avg_articles_per_month DESC;
-- Tous les articles d'un user
SELECT 
    u.firstname, 
    u.lastname,
    a.title
FROM users u
INNER JOIN articles a ON a.id_user = u.id_user
WHERE u.id_user = 1;
```

**MongoDB**

```mongo
// Exemple de pipeline d'agrégation
// Recuperer tous les commentaires d'un article
db.comments.aggregate([
    { $match: { article_id: 10 } },
    { $sort: { created_at: -1 } },
    { $project: {
            content: 1,
            created_at: 1,
            id_user: 1,
            article_id: 1
        }
    }
])
```

### 6. Stratégie de Sauvegarde
Pour cette partie, vous devez effectuer des recherches afin d'argumenter vos réponses.

- **PostgreSQL** : Méthode proposée (pg_dump, sauvegarde continue, etc.)
script s'executant toutes les semaines faisant un dump de la db au moyen de pg_dump

- **MongoDB** : Méthode proposée (mongodump, replica set, etc.)
replicas docker, soft delete et mongodump mensuel des commentaires

- **Fréquence** : Complète, incrémentale, différentielle

- **Restauration** : Procédure en cas de perte de données
Recuperation au moyen des dump effectués